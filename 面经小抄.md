# 1.linux相关

## 1.1linux进程线程创建

**进程**

（1）获取当前进程号

        pid_t getpid(void)
    
        头文件：sys/types.h、unistd.h
    
        该函数成功返回当前ID，该函数always successful

（2）获取父进程号

        pid_t getppid(void)
    
        头文件：sys/types.h、unistd.h
    
        always successful

（3）**进程创建**

       （3-1） pid_t fork(void)
    
        头文件：sys/types.h、unistd.h
    
        功能：在当前进程中创建一个进程，与父进程共享代码段，复制父进程的堆栈段和数据段，子进程复制父进程，然后执行fork()后的代码。向父进程返回创建进程的进程号，在子进程中返回0。
    
        返回值：fork返回给父进程所创建进程的进程号，然后返回创建成功标志值为0，失败-1或者errno
    
        （3-2）pid_t fork(void)
    
        头文件：sys/types.h、unistd.h
    
        功能：和fork（父子进程的执行次序不确定）类似，但vfork保证了子进程先执行，子进程退出后父进程才执行，而且在创建时不像fork分配一片新的进程空间，而是在父进程的空间里执行。

（4）**进程的退出**

        void exit(int value) //value为0代表正常退出，非0（一般1或-1）表示非正常退出，一般会有对应情况
    
        父进程：exit(0)和return(0)
    
        子进程：exit(0)

return和exit的区别是exit停止进程并且value表示进程退出状态，return是函数返回的标志可以返回多种数据类型

exit()（库函数；sdtlib.h）和_exit(系统调用;unistd.h)：终止进程以后，_exit()缓冲区不被保存，exit()缓冲区被保存

exit函数作用：进程停止运行之前，检查文件打开情况，把文件缓冲区内容写回文件。，清除其使用的内存空间，并清除其在内核中的各种数据结构。
————————————————
版权声明：本文为CSDN博主「qq_38847853」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38847853/article/details/80434781

**线程**

（1）**线程创建函数**

#include <pthread.h>
int **pthread_create**(pthread_t *restrict tidp, //是一个传出参数，用于保存成功创建线程之后对应的线程id
　　　　const pthread_attr_t *restrict attr, //线程属性，默认为NULL，如果想使用具体的属性也可以修改具体的参数
             void *(*start_rtn)(void), //指向创建线程所执行函数的入口地址，函数执行完毕，则线程结束。
                  void *restrict arg); //线程主函数执行期间所使用的参数

ret-成功返回0 失败返回错误编号。注意：由于创建线程函数是一个库函数，不是系统调用函数。所以其错误信息不能用perror()进行打印，采用strerror(错误号)可以将错误信息打印出来。其中strerror函数是包含#include<string.h>之中的一个库函数。

（2）获取线程自身ID

include <pthread.h>
pthread_t pthread_self(void);

ret-调用线程的线程ID，返回值为一个无符号长整型

说明：线程id是在一个进程中的内部标识，但不同进程中的线程id可能相同。

         进程与进程中线程的代码运行按时间先后顺序

（3）比较两个线程ID

#include <pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);

ret-若相等则返回非0值，否则返回0值

（4）**单个线程退出**

#include <pthread.h>

void **pthread_exit**(void *rval_ptr);//rval_ptr是一个无类型指针，与传递给启动例程的单个参数类似，进程中的其他线程可以通过调用pthread_join函数访问到这个指针；

返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）

（5）**等待线程结束函数**

#include <pthread.h>
int **pthread_join**(pthread_t thread, void **rval_ptr);//thread:被等待的线程标识符ID;rval_ptr:一个用户定义的指针，它可以用来存储被等待线程的返回值 

ret-成功返回0 否则返回错误编号

      调用线程一直阻塞，直到指定的线程调用pthread_exit，从启动例程中返回或者被取消；如果线程(指调用的在等待的pthread)只是从调用它等待它的例程中返回，rval_ptr将包含返回码；如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED.如果线程已经处于分离状态，pthread_t就会调用失败，返回EINVAL。如果对线程的返回值不感兴趣，可以吧rval_prt设置为NULL。这种情况下，调用pthread_join将等待线程终止，但不获取线程的终止状态。
    
        分离状态说明：在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。

说明：这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回 

（6）线程取消

#include <pthread.h>
int pthread_cancel(pthread_t tid);// thread 要取消线程的标识符ID

ret-成功返回0 失败返回错误码

功能：取消某个线程的执行。调用了参数是PTHREAD_CANCELD的pthread_exit函数，但是，线程可以选择或者忽略、或者立即终止、或者继续运行至Cancelation-point（取消点:会引起阻塞的系 统调用）。函数并不等待线程终止，它仅仅是提出请求。线程接收到CANCEL信号的缺省处理（即pthread_create()创建线程的缺省状态）是继续运行至取消点才会退出。

（7）分离释放线程（由系统回收线程所占资源）

#include <pthread.h>

int pthread_detach(pthread_t thread); // thread 要释放线程的标识符ID

返回值：若是成功返回0,否则返回错误的编号 

说 明：linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态。一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。如果线程状态为joinable,需要在之后适时调用pthread_join。

（8）线程清理处理函数

#include <pthread.h>
void pthread_cleanup_push(void(*rtn)(void*), void *arg);//rtn为清理函数，arg为清理函数的参数

void pthread_cleanup_pop(int execute); //调用删除上次push的清理程序

当线程执行以下动作时调用清理函数：a. 调用pthread_exit;b. 想用取消请求；c. 用非零的execute参数调用pthread_cleanup_pop;如果execute=0则函数不被调用；
注意正常从线程返回（return）的时候，不会调用该清理函数；

————————————————
版权声明：本文为CSDN博主「qq_38847853」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38847853/article/details/80434781

## 1.2linux进程的通讯

管道（pipe）,流管道(s_pipe)和有名管道（FIFO）

信号（signal）

消息队列

共享内存

信号量

套接字（socket)

### 管道( pipe )

------

管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

流管道s_pipe: 去除了第一种限制,可以双向传输.

管道可用于具有亲缘关系进程间的通信，命名管道:name_pipe克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

### 信号量( semophore )

------

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；

### 消息队列( message queue )

------

消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

### *信号 ( singal )*

------

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

主要作为进程间以及同一进程不同线程之间的同步手段。

![image-20210715164059366](.\图片\信号量.jpg)

程序可用使用signal函数来处理指定的信号，主要通过忽略和恢复其默认行为来工作

发送信号方法：

1、kill函数

2、alarm函数

![image-20210715164443986](.\图片\信号表.png)

### 共享内存( shared memory )

------

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

### 套接字( socket )

------

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信

更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

 

### 各种通信方式的比较和优缺点：

1. 管道：速度慢，容量有限，只有父子进程能通讯
2. FIFO：任何进程间都能通讯，但速度慢
3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
4. 信号量：不能传递复杂消息，只能用来同步
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

如果用户传递的信息较少或是需要通过信号来触发某些行为．前文提到的软中断信号机制不失为一种简捷有效的进程间通信方式．

但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求，那就需要考虑别的通信方式了。

无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：

有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。

消息缓冲可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。

共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。

但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中，所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。

共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。

不幸的是，Linux无法严格保证提供对共享内存块的独占访问，甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性。 同时，多个使用共享内存块的进程之间必须协调使用同一个键值。

## 1.3死锁

![](图片\死锁.png)

https://www.cnblogs.com/shuiyj/p/13185083.html

# 2.操作系统

## 进程的虚拟地址有多少，物理地址和虚拟地址的关系，这两种地址是怎么建立起关系的

1、虚拟地址和物理地址之间的映射是以页（4KB）为单位进行映射的；

2、每一个进程中都有一个进程控制块（PCB），里面包含了一些进程的信息（页目录，状态，句柄表，ID，PID……）；

3、映射过程（32位系统下）：

首先PCB中有一个指向一级分页表的指针，每一个页表的大小均为4096B（4KB），可以存储1024个地址。其中一级页表中每一个地址对应着一个二级页表的首地址，二级页表中也存储着1024个地址，其中每个地址分别对应着物理内存上面的每一个页的首地址。这样一来，虚拟地址空间所能够访问的地址有1024 * 1024 * 4096B = 2^32B = 4GB；正好是4G。perfect！！！！
————————————————
版权声明：本文为CSDN博主「qq_ccc」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_40508591/article/details/108154090

# N各个厂面筋&突击

## 1.蔚来

手撕代码：

1.strcpy

2.数组合并

3.给定一个字符串，将里面的大写字母变为小写

4.给定[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组nums1(大小为m+n，其中放了m个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数字，后面n个用0填充),nums2(大小为n)，将nums2和nums1合并变成新的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组放在nums1中。

5..给定一个string，按照出现频率输出新的string（如“aAabcdd”,输出“aaddAbc”(不一定要严格按照顺序，也可以是''ddaaABc'等)）

6.好像是lucky序列问题

7.stoi

8.strlok

1.计算机网络

### 如何保证？

校验和+序列号
确认应答+超时重传
拥塞控制机制
窗口机制：双方协调发送的数据包大小

### 第三次握手可以去掉吗？

不行，第三次是为了防止已经失效的连接请求报文突然传输到服务器，从而建立错误连接
其次，若第二次握手客户端没有收到，则服务器再发送数据包后收不到回应会以为丢包了而不断重发，造成死锁

### 四次挥手中，客户端为什么最后还要等待2*msl？

保证客户端发送的最后一个ACK报文能够到达服务器，这样当报文丢失了，服务端可以在2*msl内重发给客户端确认释放报文
使得本连接持续的时间内所产生的所有报文都从网络消失

### 连接三次？挥手四次？

建立连接时，服务器处于listen状态，不需要等待，可把ACK和SYN放在一个报文发给客户端
关闭连接时，服务器只接收客户端的FIN，只表示对方不再发送数据，对方可能还能接收数据或自己数据还没发完，所以ACK和FIN，ACK是分开发送的

server第二次握手将ACK置一，且进行资源分配；client第三次握手将ACK置一，且进行资源分配

### TCP粘包

就是发送方发送的若干数据包到达接收方时粘成了一个包，在缓冲区中两个数据连在一起
原因：发送方使用Nagle算法，接收方的应用层从缓冲区读取数据包的速度小于TCP将数据包保存到接收缓冲区

**介绍TCP/IP协议**

**TCP和UDP的区别**

TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先
在双方之间建立一个TCP连接，之后才能传输数据。
UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程
序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。

2.C++

**原子操作**

原子操作的实现跟普通数据类型类似，但是它能够在保证结果正确的前提下，提供比mutex等锁机制更好的性能，如果我们要访问的共享资源可以用原子数据类型表示，那么在多线程程序中使用这种新的等价数据类型

**lamba返回值**

大多数情况下lambda表达式的返回值可由编译器猜测得出，因此不需要我们指定lambda表达式的返回值类型。我们可以通过尾值返回类型的方式设置lambda表达式的返回类型。

**C和C++的区别，C++的多态是如何实现的**

c++面向对象，c面向过程

c++具有封装继承多态等特性

c++支持范式编程

**多态实现**

![image-20210725221119916](图片\多态实现.png)

3，多线程

**多任务调度，互斥信号量**

**linux多线程通信**

**线程和进程的区别**

进程是系统进行资源调度和分配得基本单位，实现了操作系统得并发，线程是进程得子任务，是cpu调度和分派得基本单位，且是系统最小得执行和调度单位。

区别：

1.线程只能属于一个进程，但是一个进程可以有多个线程。

2.进程在执行过程中有独立内存区域，但是同一进程下的线程间是共享得。

3.创建开销。

4.线程间没影响，线程一挂进程就挂。



**线程和进程切换的具体过程**

即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从上次停止的地方开始。

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

线程切换不需要进行地址空间切换，这个就是线程切换和进程切换的最大的区别

**介绍对stl的了解**

1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；
2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；
3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；
4）仿函数（Function object）
5）迭代适配器（Adaptor）
6）空间配制器（allocator）
————————————————
版权声明：本文为CSDN博主「chf_1」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/chf_1/article/details/81481265

4.单片机

**什么情况下需要进行对现场的保存和恢复**

中断，进程切换

处理中断，保存pc寄存器

**arm芯片和x86芯片**

x86架构采用CISC，而ARM采用RISC。