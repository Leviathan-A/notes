# 1.linux相关

## 1.1linux进程线程创建

**进程**

（1）获取当前进程号

        pid_t getpid(void)
    
        头文件：sys/types.h、unistd.h
    
        该函数成功返回当前ID，该函数always successful

（2）获取父进程号

        pid_t getppid(void)
    
        头文件：sys/types.h、unistd.h
    
        always successful

（3）**进程创建**

       （3-1） pid_t fork(void)
    
        头文件：sys/types.h、unistd.h
    
        功能：在当前进程中创建一个进程，与父进程共享代码段，复制父进程的堆栈段和数据段，子进程复制父进程，然后执行fork()后的代码。向父进程返回创建进程的进程号，在子进程中返回0。
    
        返回值：fork返回给父进程所创建进程的进程号，然后返回创建成功标志值为0，失败-1或者errno
    
        （3-2）pid_t fork(void)
    
        头文件：sys/types.h、unistd.h
    
        功能：和fork（父子进程的执行次序不确定）类似，但vfork保证了子进程先执行，子进程退出后父进程才执行，而且在创建时不像fork分配一片新的进程空间，而是在父进程的空间里执行。

（4）**进程的退出**

        void exit(int value) //value为0代表正常退出，非0（一般1或-1）表示非正常退出，一般会有对应情况
    
        父进程：exit(0)和return(0)
    
        子进程：exit(0)

return和exit的区别是exit停止进程并且value表示进程退出状态，return是函数返回的标志可以返回多种数据类型

exit()（库函数；sdtlib.h）和_exit(系统调用;unistd.h)：终止进程以后，_exit()缓冲区不被保存，exit()缓冲区被保存

exit函数作用：进程停止运行之前，检查文件打开情况，把文件缓冲区内容写回文件。，清除其使用的内存空间，并清除其在内核中的各种数据结构。
————————————————
版权声明：本文为CSDN博主「qq_38847853」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38847853/article/details/80434781

**线程**

（1）**线程创建函数**

#include <pthread.h>
int **pthread_create**(pthread_t *restrict tidp, //是一个传出参数，用于保存成功创建线程之后对应的线程id
　　　　const pthread_attr_t *restrict attr, //线程属性，默认为NULL，如果想使用具体的属性也可以修改具体的参数
             void *(*start_rtn)(void), //指向创建线程所执行函数的入口地址，函数执行完毕，则线程结束。
                  void *restrict arg); //线程主函数执行期间所使用的参数

ret-成功返回0 失败返回错误编号。注意：由于创建线程函数是一个库函数，不是系统调用函数。所以其错误信息不能用perror()进行打印，采用strerror(错误号)可以将错误信息打印出来。其中strerror函数是包含#include<string.h>之中的一个库函数。

（2）获取线程自身ID

include <pthread.h>
pthread_t pthread_self(void);

ret-调用线程的线程ID，返回值为一个无符号长整型

说明：线程id是在一个进程中的内部标识，但不同进程中的线程id可能相同。

         进程与进程中线程的代码运行按时间先后顺序

（3）比较两个线程ID

#include <pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);

ret-若相等则返回非0值，否则返回0值

（4）**单个线程退出**

#include <pthread.h>

void **pthread_exit**(void *rval_ptr);//rval_ptr是一个无类型指针，与传递给启动例程的单个参数类似，进程中的其他线程可以通过调用pthread_join函数访问到这个指针；

返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）

（5）**等待线程结束函数**

#include <pthread.h>
int **pthread_join**(pthread_t thread, void **rval_ptr);//thread:被等待的线程标识符ID;rval_ptr:一个用户定义的指针，它可以用来存储被等待线程的返回值 

ret-成功返回0 否则返回错误编号

      调用线程一直阻塞，直到指定的线程调用pthread_exit，从启动例程中返回或者被取消；如果线程(指调用的在等待的pthread)只是从调用它等待它的例程中返回，rval_ptr将包含返回码；如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED.如果线程已经处于分离状态，pthread_t就会调用失败，返回EINVAL。如果对线程的返回值不感兴趣，可以吧rval_prt设置为NULL。这种情况下，调用pthread_join将等待线程终止，但不获取线程的终止状态。
    
        分离状态说明：在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。

说明：这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回 

（6）线程取消

#include <pthread.h>
int pthread_cancel(pthread_t tid);// thread 要取消线程的标识符ID

ret-成功返回0 失败返回错误码

功能：取消某个线程的执行。调用了参数是PTHREAD_CANCELD的pthread_exit函数，但是，线程可以选择或者忽略、或者立即终止、或者继续运行至Cancelation-point（取消点:会引起阻塞的系 统调用）。函数并不等待线程终止，它仅仅是提出请求。线程接收到CANCEL信号的缺省处理（即pthread_create()创建线程的缺省状态）是继续运行至取消点才会退出。

（7）分离释放线程（由系统回收线程所占资源）

#include <pthread.h>

int pthread_detach(pthread_t thread); // thread 要释放线程的标识符ID

返回值：若是成功返回0,否则返回错误的编号 

说 明：linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态。一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。如果线程状态为joinable,需要在之后适时调用pthread_join。

（8）线程清理处理函数

#include <pthread.h>
void pthread_cleanup_push(void(*rtn)(void*), void *arg);//rtn为清理函数，arg为清理函数的参数

void pthread_cleanup_pop(int execute); //调用删除上次push的清理程序

当线程执行以下动作时调用清理函数：a. 调用pthread_exit;b. 想用取消请求；c. 用非零的execute参数调用pthread_cleanup_pop;如果execute=0则函数不被调用；
注意正常从线程返回（return）的时候，不会调用该清理函数；

————————————————
版权声明：本文为CSDN博主「qq_38847853」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38847853/article/details/80434781

## 1.2linux进程的通讯

管道（pipe）,流管道(s_pipe)和有名管道（FIFO）

信号（signal）

消息队列

共享内存

信号量

套接字（socket)

### 管道( pipe )

------

管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

流管道s_pipe: 去除了第一种限制,可以双向传输.

管道可用于具有亲缘关系进程间的通信，命名管道:name_pipe克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

### 信号量( semophore )

------

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；

### 消息队列( message queue )

------

消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

### *信号 ( singal )*

------

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

主要作为进程间以及同一进程不同线程之间的同步手段。

![image-20210715164059366](.\图片\信号量.jpg)

程序可用使用signal函数来处理指定的信号，主要通过忽略和恢复其默认行为来工作

发送信号方法：

1、kill函数

2、alarm函数

![image-20210715164443986](.\图片\信号表.png)

### 共享内存( shared memory )

------

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

### 套接字( socket )

------

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信

更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

 

### 各种通信方式的比较和优缺点：

1. 管道：速度慢，容量有限，只有父子进程能通讯
2. FIFO：任何进程间都能通讯，但速度慢
3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
4. 信号量：不能传递复杂消息，只能用来同步
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

如果用户传递的信息较少或是需要通过信号来触发某些行为．前文提到的软中断信号机制不失为一种简捷有效的进程间通信方式．

但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求，那就需要考虑别的通信方式了。

无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：

有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。

消息缓冲可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。

共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。

但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中，所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。

共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。

不幸的是，Linux无法严格保证提供对共享内存块的独占访问，甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性。 同时，多个使用共享内存块的进程之间必须协调使用同一个键值。

## 1.3死锁

![](图片\死锁.png)

https://www.cnblogs.com/shuiyj/p/13185083.html

# 2.操作系统

## 2.1进程线程区别

进程是系统程序运行和资源分配的基本单位；线程是cpu调度的基本单位
一个进程拥有多个线程，线程可访问所属进程资源
同一个进程下的多个线程共享一个地址空间，线程间通信简单，切换、创建开销小
进程通信麻烦，切换、创建开销较大

## 进程的虚拟地址有多少，物理地址和虚拟地址的关系，这两种地址是怎么建立起关系的

1、虚拟地址和物理地址之间的映射是以页（4KB）为单位进行映射的；

2、每一个进程中都有一个进程控制块（PCB），里面包含了一些进程的信息（页目录，状态，句柄表，ID，PID……）；

3、映射过程（32位系统下）：

首先PCB中有一个指向一级分页表的指针，每一个页表的大小均为4096B（4KB），可以存储1024个地址。其中一级页表中每一个地址对应着一个二级页表的首地址，二级页表中也存储着1024个地址，其中每个地址分别对应着物理内存上面的每一个页的首地址。这样一来，虚拟地址空间所能够访问的地址有1024 * 1024 * 4096B = 2^32B = 4GB；正好是4G。perfect！！！！
————————————————
版权声明：本文为CSDN博主「qq_ccc」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_40508591/article/details/108154090

# 3.数据结构

## 3.1红黑树

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

# 4.计算机网络

## 4.1socket

**服务器端**

socket() 创建套接字

int socket(int domain, int type, int protocol);

参数:
**domain:** 使用的地址族协议
AF_INET: 使用 IPv4 格式的 ip 地址
AF_INET6: 使用 IPv6 格式的 ip 地址
**type:**
SOCK_STREAM: 使用流式的传输协议
SOCK_DGRAM: 使用报式 (报文) 的传输协议
**protocol:** 一般写 0 即可，使用默认的协议
SOCK_STREAM: 流式传输默认使用的是 tcp
SOCK_DGRAM: 报式传输默认使用的 udp
**返回值:**
成功：可用于套接字通信的文件描述符
失败: -1



bind()：绑定本地IP地址和端口号

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
参数:
**sockfd:** 监听的文件描述符，通过 socket () 调用得到的返回值
**addr:** 传入参数，要绑定的 IP 和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序
**addrlen:** 参数 addr 指向的内存大小，sizeof (struct sockaddr)
**返回值：**成功返回 0，失败返回 - 1



listen()：设置监听队列长度

int listen(int sockfd, int backlog);
参数:
**sockfd:** 文件描述符，可以通过调用 socket () 得到，在监听之前必须要绑定 bind ()
**backlog:** 同时能处理的最大连接要求，最大值为 128
**返回值：**函数调用成功返回 0，调用失败返回 -1

accept()：等待连接

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
参数:
**sockfd:** 监听的文件描述符
**addr:** 传出参数，里边存储了建立连接的客户端的地址信息
**addrlen:** 传入传出参数，用于存储 addr 指向的内存大小
**返回值：**函数调用成功，得到一个文件描述符，用于和建立连接的这个客户端通信，调用失败返回 -1



read()：接收消息

ssize_t read(int sockfd, void *buf, size_t size);

ssize_t recv(int sockfd, void *buf, size_t size, int flags);

参数:
**sockfd:** 用于通信的文件描述符，accept () 函数的返回值
**buf:** 指向一块有效内存，用于存储接收是数据
**size:** 参数 buf 指向的内存的容量
**flags:** 特殊的属性，一般不使用，指定为 0




close()：关闭套接字

**客户端**

socket()：创建套接字
connect()：发送连接请求

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
参数:
**sockfd:** 通信的文件描述符，通过调用 socket () 函数就得到了
**addr:** 存储了要连接的服务器端的地址信息: iP 和 端口，这个 IP 和端口也需要转换为大端然后再赋值
**addrlen:** addr 指针指向的内存的大小 sizeof (struct sockaddr)
**返回值：**连接成功返回 0，连接失败返回 - 1



write()：发送信息

ssize_t write(int fd, const void *buf, size_t len);
ssize_t send(int fd, const void *buf, size_t len, int flags);

参数:
**fd:** 通信的文件描述符，accept () 函数的返回值
**buf:** 传入参数，要发送的字符串
**len:** 要发送的字符串的长度
**flags:** 特殊的属性，一般不使用，指定为 0



close()：关闭套接字

## 4.3 TCP/UDP

### 区别

TCP面向字节流、面向连接，UDP基于数据报、面向无连接
TCP结构复杂，占用资源多，提供可靠服务，UDP不提供，结构简单且占用资源少
TCP有拥塞控制，UDP没有
TCP只支持一对一，UDP支持一对一，一对多，多对一等

### 适用场景

TCP：对数据传输质量要求高，对实时性要求不高的时候(有拥塞控制，堵塞时会放慢传输速度)，如文件传输协议
UDP：对数据传输的实时性要求高，对质量要求不高的时候，如在线视频、网络电话等
TCP可靠连接
TCP传输数据满足四大条件：不出错、不丢失、不重复、不乱序，拥有窗口机制、拥塞机制等

# 5.算法

## 5.1排序

![image-20210805122238500](图片\排序表)

# N各个厂面筋&突击

## 1.蔚来

手撕代码：

1.strcpy

2.数组合并

3.给定一个字符串，将里面的大写字母变为小写

4.给定[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组nums1(大小为m+n，其中放了m个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数字，后面n个用0填充),nums2(大小为n)，将nums2和nums1合并变成新的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组放在nums1中。

5..给定一个string，按照出现频率输出新的string（如“aAabcdd”,输出“aaddAbc”(不一定要严格按照顺序，也可以是''ddaaABc'等)）

6.好像是lucky序列问题

7.stoi

8.strlok

### 1.计算机网络

**如何保证？**

校验和+序列号
确认应答+超时重传
拥塞控制机制
窗口机制：双方协调发送的数据包大小

**第三次握手可以去掉吗？**

不行，第三次是为了防止已经失效的连接请求报文突然传输到服务器，从而建立错误连接
其次，若第二次握手客户端没有收到，则服务器再发送数据包后收不到回应会以为丢包了而不断重发，造成死锁

**四次挥手中，客户端为什么最后还要等待2*msl？**

保证客户端发送的最后一个ACK报文能够到达服务器，这样当报文丢失了，服务端可以在2*msl内重发给客户端确认释放报文
使得本连接持续的时间内所产生的所有报文都从网络消失

**连接三次？挥手四次？**

建立连接时，服务器处于listen状态，不需要等待，可把ACK和SYN放在一个报文发给客户端
关闭连接时，服务器只接收客户端的FIN，只表示对方不再发送数据，对方可能还能接收数据或自己数据还没发完，所以ACK和FIN，ACK是分开发送的

server第二次握手将ACK置一，且进行资源分配；client第三次握手将ACK置一，且进行资源分配

**TCP粘包**

就是发送方发送的若干数据包到达接收方时粘成了一个包，在缓冲区中两个数据连在一起
原因：发送方使用Nagle算法，接收方的应用层从缓冲区读取数据包的速度小于TCP将数据包保存到接收缓冲区

**介绍TCP/IP协议**

**TCP和UDP的区别**

TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先
在双方之间建立一个TCP连接，之后才能传输数据。
UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程
序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。

### 2.C++

**内存分布**

**栈**，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。

**堆**，就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个 new 就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。堆可以动态地扩展和收缩。

**自由存储区**，就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的。

**全局/静态存储区**，全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。

**常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）

**原子操作**

原子操作的实现跟普通数据类型类似，但是它能够在保证结果正确的前提下，提供比mutex等锁机制更好的性能，如果我们要访问的共享资源可以用原子数据类型表示，那么在多线程程序中使用这种新的等价数据类型

**lamba返回值**

大多数情况下lambda表达式的返回值可由编译器猜测得出，因此不需要我们指定lambda表达式的返回值类型。我们可以通过尾值返回类型的方式设置lambda表达式的返回类型。

**C和C++的区别，C++的多态是如何实现的**

c++面向对象，c面向过程

c++具有封装继承多态等特性

c++支持范式编程

**多态实现**

![image-20210725221119916](图片\多态实现.png)

### 3，多线程，操作系统



**多任务调度，互斥信号量**

**linux多线程通信**

**线程和进程的区别**

进程是系统进行资源调度和分配得基本单位，实现了操作系统得并发，线程是进程得子任务，是cpu调度和分派得基本单位，且是系统最小得执行和调度单位。

区别：

1.线程只能属于一个进程，但是一个进程可以有多个线程。

2.进程在执行过程中有独立内存区域，但是同一进程下的线程间是共享得。

3.创建开销。

4.线程间没影响，线程一挂进程就挂。



**线程和进程切换的具体过程**

即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从上次停止的地方开始。

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

线程切换不需要进行地址空间切换，这个就是线程切换和进程切换的最大的区别

**进程间为什么需要通讯**

- 数据传输：一个进程需要将它的数据发送给另一个进程。
- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
- 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

**介绍对stl的了解**

1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；
2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；
3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；
4）仿函数（Function object）
5）迭代适配器（Adaptor）
6）空间配制器（allocator）
————————————————
版权声明：本文为CSDN博主「chf_1」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/chf_1/article/details/81481265

## 2.寒武纪实习

函数初始化列表；

内联函数实现；

cpu如何读取数据；

函数传参机制；

左值右值，完美转发，移动语义。

进程线程直接分别有什么是共享的。

### 4.单片机

**什么情况下需要进行对现场的保存和恢复**

中断，进程切换

处理中断，保存pc寄存器

**arm芯片和x86芯片**

x86架构采用CISC，而ARM采用RISC。

## 3.字节测开

### 1.操作系统四大特性

并发：

并发是指两个事件或者多个事件在同一时间间隔里同时发生，操作系统的并发性是指计算机系统中在一段时间内有多道程序同时执行，但在单核处理系统中，每一时刻仅有一道程序在执行，故微观上这些程序是交替执行的。操作系统中引入进程就是为了让程序更好的并发执行。

并行是指同一时刻有两个或两个以上的程序同时运行。

 

共享：

资源共享是指系统中的硬件和软件不再为某个程序所独占，而是多个程序共同使用。并发和共享是操作系统两个最基本的属性。两者之间互为存在的条件，资源共享是以程序的并发为条件的，若系统不允程序许并发执行，自然就不存在共享资源的问题。若系统不能对资源实行有效的管理，也会影响到程序的并发执行。

共享又分为同时共享和互斥共享，互斥共享指的是一段时间只允许一个程序访问该资源。

而同时共享指的是一段时间内多个进程可以交替的访问该资源。

 

虚拟：

虚拟指的是把物理上的实体变成逻辑上的对应物，物理实体是实际存在的，而逻辑上的对应物是虚拟的。

类似的可以通过虚拟技术，将一台机器的物理存储器变为虚拟存储器，以便于从逻辑上来扩充存储器的容量。

 

异步：

在多道程序的环境下，允许程序并发的执行，但是由于系统资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是系统的异步性。
————————————————
版权声明：本文为CSDN博主「小-鸟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_34402394/article/details/88360296

### 2.进程调度

无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。

**先来先服务调度算法**

**短作业(进程)优先调度算法：**

**高优先权优先调度算法：**

**高响应比优先调度算法**

**时间片轮转法**

***\*多级反馈队列调度算法：\****

批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？
批处理系统常用调度算法：
①、先来先服务：FCFS
②、最短作业优先
③、最短剩余时间优先
④、响应比最高者优先

分时系统调度算法：
①、轮转调度
②、优先级调度
③、多级队列调度
④、彩票调度

实时系统调度算法：
①、单比率调度
②、限期调度
③、最少裕度法
————————————————
版权声明：本文为CSDN博主「Chackca」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35642036/article/details/82809812

### 3.死锁

![](图片\死锁.png)

https://www.cnblogs.com/shuiyj/p/13185083.html

### **4.输入网址后**

![image-20210810212130665](图片\dns)

### 5.http和https

**一、HTTP和HTTPS的基本概念**

　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**二、HTTP与HTTPS有什么区别？**

　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**五、HTTPS的缺点**

虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：

　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

### 6.三次握手四次挥手

#### 第三次握手可以去掉吗？

不行，第三次是为了防止已经失效的连接请求报文突然传输到服务器，从而建立错误连接
其次，若第二次握手客户端没有收到，则服务器再发送数据包后收不到回应会以为丢包了而不断重发，造成死锁

#### 四次挥手中，客户端为什么最后还要等待2*msl？

保证客户端发送的最后一个ACK报文能够到达服务器，这样当报文丢失了，服务端可以在2*msl内重发给客户端确认释放报文
使得本连接持续的时间内所产生的所有报文都从网络消失

### 7.http常见错误代码

499, Client Closed Request， 客户端主动断开连接。

500, Internal Server Error , 服务器内部错误，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。

502，Bad Gateway，网关错误，它往往表示网关从上游服务器中接收到的响应是无效的。

504，Gateway Timeout，网关超时

### 8.空类占三个字节

### 9.测试物品

1. 功能测试
2. 性能测试
3. 压力测试
4. 安全性测试
5. 用户体验测试
6. 兼容性测试

## 4.美团后端

#### 1.Tcp究极版

**1.第三次握手失败**

当第三次握手失败时，服务器并不会重传ack报文，而是直接发送`RST报文段，进入CLOSED状态`。这样做的目的是为了`防止SYN洪泛攻击`。

**2.客户端得不到ack**

客户端发送 SYN 开启了三次握手，之后客户端连接的状态是 SYN_SENT，然后等待服务器回复 ACK 报文。正常情况下，服务器会在几毫秒内返回 ACK，但如果客户端迟迟没有收到 ACK 会怎么样呢？客户端会重发 SYN，重试的次数由 `tcp_syn_retries` 参数控制，默认是 6 次：

**3.SYN攻击**

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的`半连接状态`时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。

**4.半连接队列**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

