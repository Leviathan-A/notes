# 1.小红书

## 求时间冲突问题

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<fstream>
#include<string>
#include<numeric>
#include <sstream>
#include <iomanip>
#include<unordered_map>

//4
//10:00-10:30
//10:30-11:00
//11:00-11:30
//10:00-10:29
using namespace std;
static bool cmp(pair<int, int>& a, pair<int, int>& b)
{
	if (a.first == b.first)return a.second > b.second;
	else return a.second < b.second;
}
vector<pair<int,int>> trans(vector<string>& arr)
{
	vector<pair<int, int>> res;
	for (auto s : arr)
	{
		int begintime = (s[0] - '0') * 600 + (s[1] - '0') * 60 + (s[3] - '0') * 10 + (s[4] - '0');
		int endtime = (s[6] - '0') * 600 + (s[7] - '0') * 60 + (s[9] - '0') * 10 + (s[10] - '0');
		res.push_back({ begintime,endtime });
	}
	return res;
}
int main()
{
	int N;
	cin >> N;
	vector<string> arr(N);
	for(int i=0;i<N;i++)
	cin >> arr[i];

	auto time = trans(arr);
	sort(time.begin(), time.end(), cmp);

	int tail = time[0].second;
	int ans = time[0].second - time[0].first;
	for (int i=1;i<time.size();i++)
	{
		if (tail > time[i].first)continue;
		else
		{
			ans += time[i].second - time[i].first;
			tail = time[i].second;
		}
	}
	cout << ans;

	return 0;
}
```

# 2.华为8.25

## 1.最大子矩阵和

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<fstream>
#include<string>
#include<numeric>
#include <sstream>
#include <iomanip>
#include<unordered_map>
#include<set>

using namespace std;

3 4
-3 5 -1 5
2 4 -2 4
-1 3 -1 3
int maxvector(vector<int>& ve)
{
	int mymax = 0;
	int sum = 0;
	for (int i = 0; i < ve.size(); i++)
	{
		if (sum <= 0)sum = ve[i];
		else sum += ve[i];
		mymax = max(sum, mymax);
	}
	return mymax;
}
int maxvector(vector<int>& ve)
{
	if (ve.empty())return 0;

	int max = -100000;
	vector<int> maxve(ve.size() + 1);
	maxve[0] = ve[0];
	for (int i = 1; i < ve.size(); i++)
	{
		maxve[i] = (maxve[i - 1] > 0) ? (maxve[i - 1] + ve[i]) : ve[i];
		if (max < maxve[i])
			max = maxve[i];
	}
	return max;
}
int maxmat(vector<vector<int>>& mat, int m, int n)
{
	int i, j, k, max;
	max = 0;
	int sum = -INT_MIN;
	for (int i = 0; i < m; i++)
	{
		vector<int>b(n,0);
		for (j = i; j < m; j++)
		{
			for (int k = 0; k < n; k++)
			{
				b[k] += mat[j][k];
			}
			max = maxvector(b);
			if (max > sum)
			{
				sum = max;
			}
		}
	}
	return sum;
}
int main()
{
	int m, n;
	cin >> m >> n;
	vector<vector<int>> mat(m, vector<int>(n, 0));
	vector<vector<int>> dp(m, vector<int>(n, 0));
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
			cin >> mat[i][j];
	}

	cout << maxmat(mat,mat.size(), mat[0].size());
	return 0;
}

```

## 2.死亡沼泽

```c++
5 5
3 5 4 2 3
4 5 3 4 3
4 3 5 3 2
2 5 3 3 5
5 3 4 4 3

int main()
{
	int row;
	int col;
	cin >> row >> col;
	vector<vector<int>> mat(row, vector<int>(col, 0));
	vector<vector<int>> memo(row, vector<int>(col, 0));
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			cin >> mat[i][j];
		}
	}

	int dir[2][2] = { {0,1},{1,0} };
	queue<vector<int>> que;
	que.push({ 0,0 });
	memo[0][0] = 1;
	int time = -1;
	while (!que.empty())
	{
		int size = que.size();
		time++;
		for (int i = 0; i < size; i++)
		{
			auto tmp = que.front();
			que.pop();

			if ((tmp[0] == row - 1) && (tmp[1] == col - 1) && time <= mat[tmp[0]][tmp[1]])
			{
				cout << time << endl;
				return 0;
			}
			for (int i = 0; i < 2; ++i)
			{
				int nx = tmp[0] + dir[i][0];
				int ny = tmp[1] + dir[i][1];
				if (nx < 0 || nx >= row || ny<0 || ny >= col || time>mat[nx][ny] || memo[nx][ny] == 1)continue;
				que.push({ nx,ny });
				memo[nx][ny] == 1;
			}
		}
	}
	cout << -1 << endl;
	return 0;
}
```

```c++
int main()
{
	int row;
	int col;
	cin >> row >> col;
	vector<vector<int>> mat(row, vector<int>(col, 0));
	vector<vector<int>> memo(row, vector<int>(col, 0));
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			cin >> mat[i][j];
		}
	}

	int time = 0;
	memo[0][0] = 0;
	for (int i = 1; i < col; i++)
	{
		if (i >= mat[0][i]|| memo[0][i-1]==-1)memo[0][i] = -1;
		else memo[0][i] = i;
	}
	for (int i = 1; i < row; i++)
	{
		if (i >= mat[i][0]|| memo[i-1][0]==-1)memo[i][0] = -1;
		else memo[i][0] = i;
	}
	for(int i=1;i<row;i++)
		for (int j = 1; j < col; j++)
		{
			if (memo[i - 1][j] == -1 && memo[i][j - 1] == -1)
				memo[i][j] = -1;
			else if (memo[i - 1][j] == -1)
			{
				if(memo[i][j - 1] + 1 < mat[i][j])
					memo[i][j] = memo[i][j - 1] + 1;
				else memo[i][j] = -1;
			}		
			else if (memo[i][j - 1] == -1)
			{
				if(memo[i - 1][j] + 1 < mat[i][j])
					memo[i][j] = memo[i- 1][j ] + 1;
				else memo[i][j] = -1;
			}
			else if(memo[i - 1][j] != -1 && memo[i][j - 1] != -1)
				memo[i][j] = min(memo[i - 1][j], memo[i][j - 1]) + 1;

		}
	cout << memo[row - 1][col - 1];
	return 0;
}
```

## 3.依赖背包pro（拓扑背包）

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<fstream>
#include<string>
#include<numeric>
#include <sstream>
#include <iomanip>
#include<unordered_map>
#include<set>
#include<queue>
using namespace std;
unordered_map<int, int> dep;
6
3,5 2
5 3
4 5
1 2
0 3
-1 1
    ans=16
    
3
-1 1
2 2
1 3
    ans=-1
int main()
{
	int n;
	string line;
	string token;
	getline(cin, line);
	n = stoi(line);
	vector<vector<int>> data;
	vector<int> times;
	for (int i = 0; i < n; i++)
	{
		vector<int> store;
		int time;
		string tmp1,tmp2;
		getline(cin, line);
		auto pos = line.find_first_of(" ");
		tmp1 = line.substr(pos);
		tmp2 = line.substr(0, pos);
		time = stoi(tmp1);
		times.push_back(time);
		stringstream ss(tmp2);
		while (getline(ss, token, ','))
		{
			store.push_back(stoi(token));
		}
		data.push_back(store);

	}

	vector<int> in(n);
	vector<vector<int>> depend_table(n);

	for (int i = 0; i < data.size(); ++i)
	{
		for (int j = 0; j < data[i].size(); ++j)
		{
			if (data[i][j] == -1)continue;
			depend_table[data[i][j]].push_back(i);
			in[i]++;
		}
	}

	int finaltime = 0;
	queue<int> zero_in;
	for (int i = 0; i < in.size(); ++i)
	{
		if (in[i] == 0)zero_in.push(i);
	}
	vector<int> ans_order;
	//int visit = 0;
	while (!zero_in.empty())
	{
		//visit++;
		int u = zero_in.front();
		zero_in.pop();
		//t += times[u];
		ans_order.push_back(u);
		for (auto c : depend_table[u])
		{
			in[c]--;
			if (in[c] == 0)
			{
				zero_in.push(c);
			}
		}
	}

	if (ans_order.size() == n)
	{
		for (auto n : ans_order)
			finaltime += times[n];
		cout << finaltime << endl;
	}
	else cout << -1 << endl;
	return 0;
}


```

